탐색 알고리즘 DFS/BFS
======

## DFS

__DFS__ 는 Depth-First Search. <span style="color:blue">깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.</span>
DFS를 설명하기 전에 먼저 그래프의 기본 구조를 알아야 한다.
그래프는  __노드__ 와 __간선__ 으로 표현되며 이떄 노드를 __정점__ 이라고도 말한다.
그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다.
또한 두 노드가 간선으로 연결되어 있다면 '두 노드는 인접하다'라고 표현한다.

  - 인접 행렬: 2차원 배열로 그래프의 연결 관계를 표현하는 방식
  - 인접 리스트: 리스트로 그래프의 연결 관계를 표현하는 방식

__인접 행렬 방식__ 은 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식이다.
위와 같이 연결된 그래프를 인접 행렬로 표현할 때 파이썬에서는 2차원 리스트로 구현할 수 있다.
연결이 ㅗ디어 있지 않은 노드끼리는 무한의 비용이라고 작성한다.
실제 코드에서는 논리적으로 정답이 될 수 없는 큰 값 중에서 9999999999, 987654321 등의 값으로 초기화하는 경우가 많다. 
이렇게 그래프를 인접 행렬 방식으로 처리할 때에는 다음과 같이 데이터를 초기화한다.

<pre>
<code>
  # 인접 행렬 방식 예제 5-6.py
  INF = 999999999

  graph = [
    [0, 7, 5],
    [7, 0 INF],
    [5, INF, 0]
  ]

  print(graph)
</code>
</pre>

그렇다면 인접 리스트 방식에서는 데이터를 어떤 방식으로 저장할까?
인접 리스트 방식에서는 다음 그림처럼 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장한다.
<pre>
<code>
  # 인접 리스트 방식 예제
  graph = [[]for _ in range(3)]

  graph[0].append((1, 7))
  graph[0].append((2, 5))

  graph[1].append((0, 7))
  
  graph[2].append((0, 5))

  print(graph)
</code>
</pre>

이 두 방식은 어떤 차이가 있을까? 메모리 측면에서 보자면 인접 행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비된다. 반면에 인접 리스트 방식은 연결된 정보만을 저장하기 떄문에 메모리를 효율적으로 사용한다.
하지만 이와 같은 속성 땜누에 인접 리스트 방식은 인접 행렬 방식에 비해 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다. 인접 리스트 방식에서는 연결된 데이터를 하나씩 확인해야 하기 때문이다.
따라서 특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우, 인접 리스트 방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다. DFS는 탐색을 위해서 사용되는 탐색 알고리즘이라고 랬는데 구체적으로 어떻게 동작할까? DFS는 깊이 우선 탐색 알고리즘이라고 했다.
이 알고리즘은 특정한 경로로 탐샣ㄱ하다가 특정한 상황에서 최대한 깊숙히 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘이다. 
DFS는 스택 자료구조를 이용하며 구체적인 동작 과정은 다음과 같다.

  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
  2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 얺고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
  3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

깊이 우선 탐색 알고리즘인 DFS는 스택 자료구조에 기초한다는 점에서 구현이 간단하다.
실제로는 스택을 쓰지 않아도 되며 탐색을 수행함에 있어서 데이터의 개수가 N개인 경우 _O(N)_ 의 기산이 소요된다는 특징이 있다. 
또한 DFS는 스택을 이용하는 알고리즘이기 때문에 실제 구현은 재귀 함수를 이용했을 때 매우 간결하게 구현할 수 있다.

## BFS

__BFS__ 알고리즘은 <span style="color:blue">'너비 우선 탐색'</span>이라는 의미를 가진다.
쉽게 말해 <span style="color:blue">가까운 노드부터 탐색하는 알고리즘이다.</span>
DFS는 최대한 멀리 있는 노드를 우선으로 탐색하는 방식으로 동작한다.고 했는데, BFS는 그 반대다.
그렇다면 BFS는 실제로 어떤 방식으로 구현할 수 있을까? BFS구현에서는 선입선출 방식인 큐 자료구조를 이용하는 것이 정석이다. 인접한 노드를 반복적으로 큐에 놓도록 알고리즘은 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 되어, 가까운 노드부터 탐색을 진행하게 된다.
알고리즘의 정확한 동작 방식은 다음과 같다.

  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
  2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하도 방문 처리를 한다.
  3. 2번의 과정을 더이상 수행할 수 없을 때까지 반복한다. 

너비 우선 탐색 알고리즘인 BFS는 큐 자료구조에 기초한다는 점에서 구현이 간단하다.
실제로 구현함에 있어 앞서 언급한 대로 deque 라이브러리를 사용하는 것이 좋으며 탐색을 수행함에 있어 _O(N)_ 의 시간이 소요된다. 일반적인 경우 실제 수행 시간은 DFS보다 좋은 편이라는 점까지만 추가로 기억하자.

| | DFS | BFS |
|-|----| --- |
| 동작 원리 | 스택 | 큐 |
| 구현 방법 | 재귀 함수 이용 | 큐 자료구조 이용 |

앞서 DFS와 BFS를 설명하는 데 전형적인 그래프 그림을 이용했는데 1차원 배열이나 2차원 배열 또한 그래프 형태로 생각하면 수월하게 문제를 풀 수 있다.
특히나 DFS와 BFS 문제 유형이 그러하다.
